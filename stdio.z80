; puts
; putchar
; printf

_puts:
    push iy
    ld iy,0
    add iy,sp

    ld l,(iy+4)   ; pointer to text
    ld h,(iy+5)

    push hl
    pop ix

_puts_start:
    ld a,(ix+0)
    cp 0
        
    jp z, _puts_done
    
    cp '\'
    jr nz,_puts_not_nl

    ld a,(ix+1)
    cp 'n'
    
    jp nz, not_nl

    ld hl,(_putchar_pos)    
    ld bc,32    ; \n
    add hl,bc
    ld a,l
    and %11100000
    ld l,a
    ld (_putchar_pos),hl
    
    inc ix
    inc ix
    
    jr _puts_start

_puts_not_nl:
    ld a,(ix+0)
    ld hl,(_putchar_pos)

    call asc   ; bc points to glyph

    ld a,00111001b  ; ink 1, paper 7, not bright, not flash
    call print
    
    inc hl
    inc ix

    ld (_putchar_pos),hl
    
    jp _puts_start    

_puts_done:
    ld sp,iy
    pop iy

    ret

; ========================================================

; set Z if 'd' or 'p'
_isxp:
    cp 'x'
    ret z
    cp 'p'
    ret
    
_printf_buf ds 10
_printf:
    push iy
    ld iy,0
    add iy,sp
    
    ld l,(iy+4)
    ld h,(iy+5)

    push hl
    pop ix        ; pointer to fmt string
    
    push iy
    pop hl

    ld bc,6
    add hl,bc
    push hl     ; store arg to use for conversions

start:
    ld a,(ix+0)
    cp 0
        
    jp z, done
    
    cp '\'
    jr nz, not_nl

    ld a,(ix+1)
    cp 'n'
    
    jr nz, not_nl

    ld hl,(_putchar_pos)    
    ld bc,32    ; \n
    add hl,bc
    ld a,l
    and %11100000
    ld l,a
    ld (_putchar_pos),hl
    
    inc ix
    inc ix
    
    jr start
    
not_nl:

    ld a,(ix+0)
    cp '%'
    jp nz,not_percent

    ld a,(ix+1)    
    call _isxp
    jr nz,not_percentxp
    
; %x, %p

    pop hl    
    ld e,(hl)   ; next arg
    inc hl
    ld d,(hl)
    inc hl
    push hl
    
    ld hl,_printf_buf
    
    ld a,d
    call u8toh
    
    ld a,e
    call u8toh

    ld hl,(_putchar_pos)
    
    ld a,(_printf_buf)
    call asc
    ld a,00111001b
    call print    
    inc hl

    ld a,(_printf_buf+1)
    call asc
    ld a,00111001b
    call print
    inc hl

    ld a,(_printf_buf+2)
    call asc
    ld a,00111001b
    call print    
    inc hl

    ld a,(_printf_buf+3)
    call asc
    ld a,00111001b
    call print
    inc hl
    
    ld (_putchar_pos),hl
    
    inc ix
    inc ix
    
    jp start
    
not_percentxp:

    cp 'd'  ; %d
    
    jr nz,not_percentd
    
; %d

    pop hl    
    ld e,(hl)   ; next arg
    inc hl
    ld d,(hl)
    inc hl
    push hl
    
    push de
    pop hl
    
    push ix     ; store
    
    ld ix,_printf_buf

    call u16tod
    
    pop ix      ; recover pointer to fmt string
    
    ld hl,(_putchar_pos)
    
    ld a,(_printf_buf)
    cp '0'
    jr z,_printf1
    call asc
    ld a,00111001b
    call print    
    inc hl

_printf1:
    ld a,(_printf_buf+1)
    cp '0'
    jr z,_printf2
    call asc
    ld a,00111001b
    call print
    inc hl

_printf2:
    ld a,(_printf_buf+2)
    cp '0'
    jr z,_printf3
    call asc
    ld a,00111001b
    call print    
    inc hl

_printf3:
    ld a,(_printf_buf+3)
    cp '0'
    jr z,_printf4

    call asc
    ld a,00111001b
    call print
    inc hl

_printf4:
    ld a,(_printf_buf+4)
    call asc
    ld a,00111001b
    call print
    inc hl
    
    ld (_putchar_pos),hl

    inc ix
    inc ix
    
    jp start
    
not_percentd:

    cp 's'     ; %s
    
    jr nz,not_percents
    
; %s

    pop hl
    ld e,(hl)
    inc hl
    ld d,(hl)
    inc hl
    push hl

    push ix  ; store
    push de    

    call _puts

    pop de    ; clean stack
    pop ix
    
    inc ix
    inc ix
        
    jp start
    
not_percents:

    cp 'c'
    jr nz,not_percent
    
; %c

    pop hl
    ld a,(hl)
    inc hl
    inc hl
    push hl

    ld hl,(_putchar_pos)
    
    call asc
    ld a,00111001b
    call print    
    inc hl

    ld (_putchar_pos),hl
    
    inc ix
    inc ix
    
    jp start
            
not_percent:

    ld a,(ix+0)
    ld hl,(_putchar_pos)

    call asc   ; bc points to glyph

    ld a,00111001b  ; ink 1, paper 7, not bright, not flash
    call print
    
    inc hl
    inc ix

    ld (_putchar_pos),hl
    
    jp start    

done:
    pop hl
    
    ld sp,iy
    pop iy

    ret
    
; =======================================================

_putchar_pos: dw 0
_putchar:

    push iy
    ld iy,0
    add iy,sp
    
    ld hl,(_putchar_pos)
    
    ld a,(iy+4)   ; ascii
    
    cp 10
    jr nz, _putchar_skip
    
    ld bc,32
    add hl,bc
    ld a,l
    and %11100000
    ld l,a
    ld (_putchar_pos),hl

    ld sp,iy
    pop iy

    ret
    
_putchar_skip:
    
    call asc   ; bc points to glyph

    ld a,00111001b  ; ink 1, paper 7, not bright, not flash
    call print
    
    inc hl
    
    ld (_putchar_pos),hl
    
    ld sp,iy
    pop iy

    ret

; ----------------------------------------------------------------
; convert A to hex string and store in string at HL. Increase HL
; destroys A, BC
; ----------------------------------------------------------------

u8toh:
        ld c,-16
        call u8toh1
        ld c,-1
u8toh1: ld  b,'0'-1 ; 47
u8toh2: inc b
        add a,c
        jr c,u8toh2
        sub c

        push af
        ld a,b    ; if (a>=58) a+=7; (jump past if a<58)
        cp 58     ; a=48 carry ... a=57 carry, a=58 no carry
        jr c, u8toh3
        add a,7     ; 65 - 58
u8toh3: ld b,a
        pop af

        ld (hl),b               ; digit in b
        inc hl
        ret
        
; ----------------------------------------------------------------
; convert A to dec string and store in string at HL. Increase HL
; destroys A, BC
; i8tod: signed char
; i8tod: unsigned char
; ----------------------------------------------------------------

i8tod:

    bit 7,a
    jr z,u8tod
    
    ld c,'-'
    ld (hl),c
    inc hl
    
    neg

u8tod:
    ld c,-100
    call Na1
    ld c,-10
    call Na1
     ld c,-1
Na1: ld b,'0'-1
Na2: inc b
     add a,c
     jr	c,Na2
     sub c                   ; works as add 100/10/1
     ld (hl),b               ; digit in b
     inc hl
	 ret

; ----------------------------------------------------------------
; convert HL to hex string and store in string at IX. Increase IX
; destroys HL, BC, A
; i16tod: signed int
; i16tou: unsigned int
; ----------------------------------------------------------------

i16tod:

    bit 7,h
    jr z,u16tod
    
    ld a,'-'
    ld (ix+0),a
    inc ix
    
    ld a,h
    cpl
    ld h,a
    
    ld a,l
    cpl
    ld l,a
    inc hl

u16tod:
    ld bc,-10000
    call u16tod1
    ld bc,-1000
    call u16tod1
    ld bc,-100
    call u16tod1
    ld bc,-10
    call u16tod1
    ld bc,-1
u16tod1: 
    ld a,'0'-1
u16tod2:
    inc a
    add hl,bc
    jr c,u16tod2
    or a
    sbc hl,bc                   ; works as add 10000 etc
    ld (ix+0),a                 ; digit in a
    inc ix
	ret

; ----------------------------------------------------------------
; convert HL to hex string and store in string at IX. Increase IX
; destroys HL, BC, A
; eg HL=3.5
; ----------------------------------------------------------------

; a=0                   hl=1.0
; a=4,  2^4 =   16,    hl=10.0
; a=7,  2^7 =  128,   hl=100.0
; a=10, 2^10= 1024,  hl=1000.0
; a=14, 2^14=16384, hl=10000.0

getdecexp:
    ld de,0.1
    cp 0+15
    ret c

    ld de,%0 01111 0000000000 ; 1.0
    cp 4+15
    ret c

    ld de,%0 10010 0100000000 ; 10.0
    cp 7+15
    ret c
    
    ld de,%0 10101 1001000000; 100.0 (1+1/2+1/16)*64 = 64+32+4
    cp 10+15
    ret c

    ld de,%0 11000 1111010000  ; 1000.0 (1+1/2+1/4+1/8+1/16+1/64)*512 512+256+128+64+32+8
    cp 14+15
    ret c
    
    ld de,10000.0
    ret
        
f16tod:

    bit 7,h
    jr z, skipminus
    
    ld a,'-'
    ld (ix+0),a
    inc ix
    
skipminus:

    ld a,h
    and %01111100
    sra a
    sra a    ; a is now the exponent value (1-30)
        
    call getdecexp   ; eg 2^8 -> 10^2, de=100.0
        
    push hl
    push de
    call fdiv  ; hl=hl/10^2 = 3.5 got rid of exponent
    pop bc
    pop bc ; clean

    ld b,5
loop:
    push bc

    push hl
    call float2int  ; hl=3
    ; hl still pushed (3.5)
    ld a,l
    add a,'0'
    
    ld (ix+0),a   ; ascii
    inc ix

    push hl    
    call int2float ; hl=3.0
    pop bc
    ex de,hl ; de=3.0
    pop hl ; hl=3.5
    
    push de
    push hl
    call fsub  ; hl = 0.5
    pop bc
    pop bc ; clean
    
    ld a,h  ;  nothing left we are done, early return
    or l
    ret z

    ld d,%01001001
    ld e,0       ; de=10.0

    push de
    push hl
    call fmul  ; hl = 5.0
    pop bc
    pop bc ; clean

    pop bc ; loop counter, max of 5 steps
    
    djnz loop
        
    ret

; ----------------------------------------------------------------
; SPECTRUM SPECIFIC and affects IX
; These print routines from Cliffhanger in INPUT magazine.
; I could have used ROM RSTs but don't like them!
; "me" prints text string (data: IX) length "B" on the screen at position "HL", colour "A". 
; increases ix and hl so can be called multiple times to print more text
; "cl" clears the screen but doesn't change attributes
; "print" draws a single UDG at HL, colour A, glyph data at BC. Can also be used for simple Sprites
; ----------------------------------------------------------------

me    push bc
      push af
      ld a,(ix+0)
      call asc
      pop af
      call print
      inc hl
      inc ix
      pop bc
      djnz me
      ret

asc   push hl        ; helper routine used by "me"
      ld hl,15608    ; beginning of char set glyphs in Spectrum ROM
      ld de,8
      ld b,31
      sub b
ash   add hl,de
      dec a
      jr nz,ash
      push hl
      pop bc
      pop hl
      ret

cl    ld ix,16384    ; beginning of screen memory
      ld hl,6144     ; length of screen memory excl. attributes
      ld a,0
clp   ld (ix+0),a
      inc ix
      dec hl
      push hl
      ld de,0
      sbc hl,de
      pop hl
      jr nz,clp
      ret

print push af         ; helper used by "me" and extensively below
      push hl         ; Draw single UDG at HL, colour a, gfx data at BC
      push bc
      push hl
      pop de
      ld a,d
      cp 1
      jr c,next
      push de
      ld de,1792
      add hl,de
      pop de
      ld a,d
      cp 1
      jr z,next
      push de
      ld de,1792
      add hl,de
      pop de
next  push de
      ld de,16384
      add hl,de
      pop de
      ld a,8
      pop bc
      push af
rpt   ld a,(bc)   ; INPUT used 'rept' but we can't as it seems to be an assembler directive
      ld (hl),a
      inc h
      inc bc
      pop af
      dec a
      jr z,exit
      push af
      jr rpt
exit  pop hl
      pop af      ; passed in value of A
      push de
      ld de,22528 ; beginning of attributes area
      add hl,de
      pop de
      ld (hl),a
      push de
      pop hl
      ret
