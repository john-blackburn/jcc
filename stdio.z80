; puts
; printf
; sprintf
; putchar
; getchar 
; gets (extra limit argument)
; sscanf

; stdlib.c:
; strtol
; strtod
; malloc
; free
; exit

; math.c:
; sin
; cos
; tan
; exp
; log
; pow
; sqrt

; -------------------------------------------------------------
; PUTS(char *p)
; -------------------------------------------------------------

_puts:
    push iy
    ld iy,0
    add iy,sp

    ld l,(iy+4)   ; pointer to text
    ld h,(iy+5)

    push hl
    pop ix

_puts_start:
    ld a,(ix+0)
    cp 0
        
    jp z, _puts_done
    
    cp '\'
    jr nz,_puts_not_nl

    ld a,(ix+1)
    cp 'n'
    
    jp nz, not_nl

    ld hl,(_putchar_pos)    
    ld bc,32    ; \n
    add hl,bc
    ld a,l
    and %11100000
    ld l,a
    ld (_putchar_pos),hl
    
    inc ix
    inc ix
    
    jr _puts_start

_puts_not_nl:
    ld a,(ix+0)
    ld hl,(_putchar_pos)

    call asc   ; bc points to glyph

    ld a,00111001b  ; ink 1, paper 7, not bright, not flash
    call print
    
    inc hl
    inc ix

    ld (_putchar_pos),hl
    
    jp _puts_start    

_puts_done:
    ld sp,iy
    pop iy

    ret

; -------------------------------------------------------------
; PRINTF
; -------------------------------------------------------------

; set Z if 'd' or 'p'
_isxp:
    cp 'x'
    ret z
    cp 'p'
    ret
    
_printf_buf ds 10
_printf:
    push iy
    ld iy,0
    add iy,sp
    
    ld l,(iy+4)
    ld h,(iy+5)

    push hl
    pop ix        ; pointer to fmt string
    
    push iy
    pop hl

    ld bc,6
    add hl,bc
    push hl     ; store arg to use for conversions

start:
    ld a,(ix+0)
    cp 0
        
    jp z, done
    
    cp '\'
    jr nz, not_nl

    ld a,(ix+1)
    cp 'n'
    
    jr nz, not_nl

    ld hl,(_putchar_pos)    
    ld bc,32    ; \n
    add hl,bc
    ld a,l
    and %11100000
    ld l,a
    ld (_putchar_pos),hl
    
    inc ix
    inc ix
    
    jr start
    
not_nl:

    ld a,(ix+0)
    cp '%'
    jp nz,not_percent

    ld a,(ix+1)    
    call _isxp
    jr nz,not_percentxp
    
; %x, %p

    pop hl    
    ld e,(hl)   ; next arg
    inc hl
    ld d,(hl)
    inc hl
    push hl
    
    ld hl,_printf_buf
    
    ld a,d
    call u8toh
    
    ld a,e
    call u8toh

    ld hl,(_putchar_pos)
    
    ld a,(_printf_buf)
    call asc
    ld a,00111001b
    call print    
    inc hl

    ld a,(_printf_buf+1)
    call asc
    ld a,00111001b
    call print
    inc hl

    ld a,(_printf_buf+2)
    call asc
    ld a,00111001b
    call print    
    inc hl

    ld a,(_printf_buf+3)
    call asc
    ld a,00111001b
    call print
    inc hl
    
    ld (_putchar_pos),hl
    
    inc ix
    inc ix
    
    jp start
    
not_percentxp:

    cp 'f'   ; %f
    
    jr nz,not_percentf

; %f

    pop hl    
    ld e,(hl)   ; next arg
    inc hl
    ld d,(hl)
    inc hl
    push hl
    
    push de
    pop hl     ; the float16
    
    push ix     ; store
    
    ld ix,_printf_buf

    call f16tod

    ld hl,(_putchar_pos)

    ld a,(_printf_buf)   ;  space or minus
    call asc
    ld a,00111001b
    call print
    inc hl
    
    ld a,(_printf_buf+1)   ; first digit might be more than '9'
    cp '9'+1
    
    jr c,skip2
    
    ld a,'1'
    call asc
    ld a,00111001b
    call print
    inc hl

    ld a,(_printf_buf+1)    
    sub 10
    
skip2:

    call asc
    ld a,00111001b
    call print
    inc hl
    
    ld a,'.'
    call asc
    ld a,00111001b
    call print
    inc hl
    
    ld (_putchar_pos),hl

    ld ix,_printf_buf+2
    push ix
    call _puts
    pop ix ; clean

    pop ix      ; recover pointer to fmt string
    inc ix      ; bypass %f
    inc ix
    jp start
    
not_percentf:

    cp 'd'  ; %d
    
    jr nz,not_percentd
    
; %d

    pop hl    
    ld e,(hl)   ; next arg
    inc hl
    ld d,(hl)
    inc hl
    push hl
    
    push de
    pop hl
    
    push ix     ; store
    
    ld ix,_printf_buf

    call i16tod
    
    pop ix      ; recover pointer to fmt string
    
    ld hl,(_putchar_pos)
    
    ld a,(_printf_buf)
    cp '0'
    jr z,_printf1
    call asc
    ld a,00111001b
    call print    
    inc hl

_printf1:
    ld a,(_printf_buf+1)
    cp '0'
    jr z,_printf2
    call asc
    ld a,00111001b
    call print
    inc hl

_printf2:
    ld a,(_printf_buf+2)
    cp '0'
    jr z,_printf3
    call asc
    ld a,00111001b
    call print    
    inc hl

_printf3:
    ld a,(_printf_buf+3)
    cp '0'
    jr z,_printf4

    call asc
    ld a,00111001b
    call print
    inc hl

_printf4:
    ld a,(_printf_buf+4)
    call asc
    ld a,00111001b
    call print
    inc hl
    
    ld (_putchar_pos),hl

    inc ix
    inc ix
    
    jp start
    
not_percentd:

    cp 's'     ; %s
    
    jr nz,not_percents
    
; %s

    pop hl
    ld e,(hl)
    inc hl
    ld d,(hl)
    inc hl
    push hl

    push ix  ; store
    push de    

    call _puts

    pop de    ; clean stack
    pop ix
    
    inc ix
    inc ix
        
    jp start
    
not_percents:

    cp 'c'
    jr nz,not_percent
    
; %c

    pop hl
    ld a,(hl)
    inc hl
    inc hl
    push hl

    ld hl,(_putchar_pos)
    
    call asc
    ld a,00111001b
    call print    
    inc hl

    ld (_putchar_pos),hl
    
    inc ix
    inc ix
    
    jp start
            
not_percent:

    ld a,(ix+0)
    ld hl,(_putchar_pos)

    call asc   ; bc points to glyph

    ld a,00111001b  ; ink 1, paper 7, not bright, not flash
    call print
    
    inc hl
    inc ix

    ld (_putchar_pos),hl
    
    jp start    

done:
    pop hl
    
    ld sp,iy
    pop iy

    ret
    
; -------------------------------------------------------------
; PUTCHAR
; -------------------------------------------------------------

_putchar_pos: dw 0
_putchar:

    push iy
    ld iy,0
    add iy,sp
    
    ld hl,(_putchar_pos)
    
    ld a,(iy+4)   ; ascii
    
    cp 10
    jr nz, _putchar_skip
    
    ld bc,32
    add hl,bc
    ld a,l
    and %11100000
    ld l,a
    ld (_putchar_pos),hl

    ld sp,iy
    pop iy

    ret
    
_putchar_skip:
    
    call asc   ; bc points to glyph

    ld a,00111001b  ; ink 1, paper 7, not bright, not flash
    call print
    
    inc hl
    
    ld (_putchar_pos),hl
    
    ld sp,iy
    pop iy

    ret
    
; =====================================================

; ----------------------------------------------------------------
; convert A to hex string and store in string at HL. Increase HL
; destroys A, BC
; ----------------------------------------------------------------

u8toh:
        ld c,-16
        call u8toh1
        ld c,-1
u8toh1: ld  b,'0'-1 ; 47
u8toh2: inc b
        add a,c
        jr c,u8toh2
        sub c

        push af
        ld a,b    ; if (a>=58) a+=7; (jump past if a<58)
        cp 58     ; a=48 carry ... a=57 carry, a=58 no carry
        jr c, u8toh3
        add a,7     ; 65 - 58
u8toh3: ld b,a
        pop af

        ld (hl),b               ; digit in b
        inc hl
        ret
        
; ----------------------------------------------------------------
; convert A to dec string and store in string at HL. Increase HL
; destroys A, BC
; i8tod: signed char
; u8tod: unsigned char
; ----------------------------------------------------------------

i8tod:

    bit 7,a
    jr z,u8tod
    
    ld c,'-'
    ld (hl),c
    inc hl
    
    neg

u8tod:
    ld c,-100
    call Na1
    ld c,-10
    call Na1
     ld c,-1
Na1: ld b,'0'-1
Na2: inc b
     add a,c
     jr	c,Na2
     sub c                   ; works as add 100/10/1
     ld (hl),b               ; digit in b
     inc hl
	 ret

; ----------------------------------------------------------------
; convert HL to hex string and store in string at IX. Increase IX
; destroys HL, BC, A
; i16tod: signed int
; i16tou: unsigned int
; ----------------------------------------------------------------

i16tod:

    bit 7,h
    jr z,u16tod
    
    ld a,'-'
    ld (ix+0),a
    inc ix
    
    ld a,h
    cpl
    ld h,a
    
    ld a,l
    cpl
    ld l,a
    inc hl

u16tod:
    ld bc,-10000
    call u16tod1
    ld bc,-1000
    call u16tod1
    ld bc,-100
    call u16tod1
    ld bc,-10
    call u16tod1
    ld bc,-1
u16tod1: 
    ld a,'0'-1
u16tod2:
    inc a
    add hl,bc
    jr c,u16tod2
    or a
    sbc hl,bc                   ; works as add 10000 etc
    ld (ix+0),a                 ; digit in a
    inc ix
	ret

; d = log10(2^b) = b log10(2)=0.30103*b
;
;  b	d	    floor(d)
; -14	-4.2	-5  0.00001
; -13	-3.9	-4
; -12	-3.6	-4
; -11	-3.3	-4
; -10	-3.01	-4	0.0001
; -9	-2.7	-3
; -8	-2.4	-3
; -7	-2.1	-3	0.001
; -6	-1.8	-2
; -5	-1.5	-2	
; -4	-1.2    -2	0.01	2^-4 = 0.0625
; -3	-0.9	-1	0.1
; -2	-0.6 	-1	0.1
; -1	-0.3	-1	0.1
; 0     0	    0	1
; 1	    0.3	    0   1
; 2	    0.6	    0	1
; 3 	0.9	    0	1
; 4	    1.2	    1	10
; 5	    1.5	    1	10
; 6	    1.8	    1	10
; 7	    2.1	    2	100
; 8	    2.4	    2	100
; 9	    2.7	    2	100
; 10	3.01	3	1000
; 11	3.3	    3	1000
; 12 	3.6	    3	1000
; 13	3.9	    3  	1000
; 14	4.12	4	10000
; 15 	4.5	    4	10000

getdecexp:
    ld de,0         ; 0.00001 (shouldn't happen)
    cp -13+15
    ret c

    ld de,0x068d   ; 0.0001 
    ld (ix+4),'e'
    ld (ix+5),'-'
    ld (ix+6),'4'
    cp -9+15
    ret c
    
    ld de,0x1418 ; 0.001
    ld (ix+4),'e'
    ld (ix+5),'-'
    ld (ix+6),'3'
    cp -6+15
    ret c
    
    ld de,0x211e ; 0.01
    ld (ix+4),'e'
    ld (ix+5),'-'
    ld (ix+6),'2'
    cp -3+15
    ret c
    
    ld de,0x2e66 ; 0.1 0 01011 1001100110
    ld (ix+4),'e'
    ld (ix+5),'-'
    ld (ix+6),'1'
    cp 0+15
    ret c
        
    ld de,%0011110000000000 ; 1.0
    ld (ix+4),'e'
    ld (ix+5),'+'
    ld (ix+6),'0'
    cp 4+15
    ret c

    ld de,%0100100100000000 ; 10.0
    ld (ix+4),'e'
    ld (ix+5),'+'
    ld (ix+6),'1'
    cp 7+15
    ret c
    
    ld de,%0101011001000000; 100.0 (1+1/2+1/16)*64 = 64+32+4
    ld (ix+4),'e'
    ld (ix+5),'+'
    ld (ix+6),'2'
    cp 10+15
    ret c

    ld de,%0110001111010000  ; 1000.0 (1+1/2+1/4+1/8+1/16+1/64)*512 512+256+128+64+32+8
    ld (ix+4),'e'
    ld (ix+5),'+'
    ld (ix+6),'3'
    cp 14+15
    ret c
    
    ld de,%0111000011100010 ;  10000.0 (1+1/8+1/16+1/32+1/512)*8192 8192+1024+512+256+16
    ld (ix+4),'e'
    ld (ix+5),'+'
    ld (ix+6),'4'
    ret
    
; set a (int) to its absolute value
aabs:
    bit 7,a
    ret z
    neg
    ret

; ----------------------------------------------------------------
; convert HL float to dec string and store at IX. Increase IX
; destroys HL, BC, A
; eg HL=3.5 (0x4300) -> "3.500e+1"
; ----------------------------------------------------------------
        
f16tod:

    ld (ix+0),' '

    bit 7,h
    jr z, skipminus
    
    ld (ix+0),'-'
    
skipminus:

    inc ix

    ld a,h
    and %01111100
    sra a
    sra a    ; a is now the exponent value (1-30)
        
    call getdecexp   ; eg 2^8 -> 10^2, de=100.0
        
    push de
    push hl
    call _fidiv  ; hl=hl/10^2 = 3.5 got rid of exponent
    pop bc
    pop bc ; clean

    ld b,4
f16tod_loop:
    push bc

    push hl
    call _float2int  ; hl=3
    ; hl still pushed (3.5)
    ld a,l
    call aabs
    add a,'0'
    
    ld (ix+0),a   ; ascii
    inc ix

    push hl    
    call _int2float ; hl=3.0
    pop bc
    ex de,hl ; de=3.0
    pop hl ; hl=3.5
    
    push de
    push hl
    call _fsub  ; hl = 0.5
    pop bc
    pop bc ; clean
    
    ld d,%01001001
    ld e,0       ; de=10.0

    push de
    push hl
    call _fimul  ; hl = 5.0
    pop bc
    pop bc ; clean

    pop bc ; loop counter, 4 sig figs
    
    djnz f16tod_loop
    
    ld (ix+3),0  ; end of string

    ret

; ----------------------------------------------------------------
; SPECTRUM SPECIFIC and affects IX
; These print routines from Cliffhanger in INPUT magazine.
; "me" prints text string (data: IX) length "B" on the screen at position "HL", colour "A". 
; increases ix and hl so can be called multiple times to print more text
; "cl" clears the screen but doesn't change attributes
; "print" draws a single UDG at HL, colour A, glyph data at BC. Can also be used for simple Sprites
; ----------------------------------------------------------------

me    push bc
      push af
      ld a,(ix+0)
      call asc       ; takes A and returns BC, pointer to glyph data
      pop af
      call print
      inc hl
      inc ix
      pop bc
      djnz me
      ret

asc   push hl        ; helper routine used by "me"
      ld hl,15608    ; beginning of char set glyphs in Spectrum ROM
      ld de,8
      ld b,31
      sub b
ash   add hl,de
      dec a
      jr nz,ash
      push hl
      pop bc
      pop hl
      ret

print push af         ; helper used by "me" and extensively below
      push hl         ; Draw single UDG at HL, colour a, gfx data at BC
      push bc
      push hl
      pop de
      ld a,d
      cp 1
      jr c,next
      push de
      ld de,1792
      add hl,de
      pop de
      ld a,d
      cp 1
      jr z,next
      push de
      ld de,1792
      add hl,de
      pop de
next  push de
      ld de,16384
      add hl,de
      pop de
      ld a,8
      pop bc
      push af
rpt   ld a,(bc)   ; INPUT used 'rept' but we can't as it seems to be an assembler directive
      ld (hl),a
      inc h
      inc bc
      pop af
      dec a
      jr z,exit
      push af
      jr rpt
exit  pop hl
      pop af      ; passed in value of A
      push de
      ld de,22528 ; beginning of attributes area
      add hl,de
      pop de
      ld (hl),a
      push de
      pop hl
      ret
