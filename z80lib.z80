;----------------------------------------------------
;_FMUL:
; HL=(IY+4)*(IY+6)
;     HBC    LDE
; return HL
; destroys A, BC, DE
; 0 01111 10 | 00000000 BC
; 0 01111 10 | 00000000 DE (1.5)
;
; low bit of DE set? Add BC into total in HL and shift HL right
;----------------------------------------------------

_fimul:
    push iy
    ld iy,0
    add iy,sp

    ld h,(iy+5)
    ld c,(iy+4)   ; BC is first factor
    ld b,(iy+5)  

    ld l,(iy+7)
    ld e,(iy+6)   ; DE is seconds factor
    ld d,(iy+7)
    
    ; special cases
    ld a,b
    res 7,a   ; -0 is zero
    or c
    jr nz, _fmul_bc_nz
    
    ld hl,0   ; first factor is 0, return 0
    
    ld sp,iy
    pop iy

    ret

_fmul_bc_nz:    
    ld a,e
    res 7,a   ; -0 is zero
    or d
    jr nz, _fmul_de_nz
    
    ld hl,0  ; second factor is 0 return 0

    ld sp,iy
    pop iy

    ret

_fmul_de_nz:    
    push hl ; store exponents
    
    ld a,b
    and %00000011 ; bc is mantissa
    ld b,a
    set 2,b ; put leading 1
    
    ld a,d
    and %00000011 ; de is mantissa
    ld d,a
    set 2,d ; put leading 1

    ld hl,0 ; result

    bit 0,e
    jr z,_fmul1
    
    add hl,bc
    
_fmul1:

    sra h
    rr l

    bit 1,e
    jr z,_fmul2
    
    add hl,bc

_fmul2:

    sra h
    rr l

    bit 2,e
    jr z,_fmul3
    
    add hl,bc

_fmul3:

    sra h
    rr l

    bit 3,e
    jr z,_fmul4
    
    add hl,bc

_fmul4:

    sra h
    rr l

    bit 4,e
    jr z,_fmul5
    
    add hl,bc

_fmul5:

    sra h
    rr l

    bit 5,e
    jr z,_fmul6
    
    add hl,bc

_fmul6:

    sra h
    rr l

    bit 6,e
    jr z,_fmul7
    
    add hl,bc

_fmul7:

    sra h
    rr l

    bit 7,e
    jr z,_fmul8
    
    add hl,bc

_fmul8:

    sra h
    rr l

    bit 0,d
    jr z,_fmul9
    
    add hl,bc

_fmul9:

    sra h
    rr l

    bit 1,d
    jr z,_fmul10
    
    add hl,bc
    
_fmul10:

    sra h
    rr l

    bit 2,d
    jr z,_fmul11
    
    add hl,bc

_fmul11:    

    pop bc ; get exponents back
    push bc
    pop de ; copy of exponents
    
    ld a,b
    and %01111100
    ld b,a
    sra b
    sra b   ; b is factor1 exponent
    
    ld a,d
    and %10000000
    ld d,a  ; d is factor1 sign
    
    ld a,c
    and %01111100
    ld c,a
    sra c
    sra c   ; c is factor2 exponent
    
    ld a,e
    and %10000000
    ld e,a  ; e is factor2 sign
    
    ld a,b
    add a,c
    sub 15  ; exponent offset
    bit 3,h  ; is there a 1 at bit position 11? If so, shift
    
    jr z,_fmul_skip
    
    inc a      ; exponent must be 1 more
    sra h
    rr l       ; shift hl right so 1 at bit 10

_fmul_skip:

    sla a
    sla a   ; result exponent back in place

    or d    ; bolt on signs
    xor e
    
    ld d,a
    
    ld a,h
    and %00000011   ; get rid of leading 1
    or d            ; put on exponent and sign
    
    ld h,a

    ld sp,iy
    pop iy

    ret
    
;----------------------------------------------------
;_FDIV:
; HL=(IY+4)/(IY+6)
;     BHL    CDE
; return HL
; destroys A, BC, DE
;
; 0 01111 10 | 00000000 1.5 HL
; 0 01110 00 | 00000000 0.5 DE
;
;        110 | 00000000 mantissa 1.5 HL
;      - 100 | 00000000 mantissa 0.5 DE
;         10 | 00000000 HL
; subtract, not carry so inc BC (result), shift BC left, shift HL left
;        100 | 00000000 HL   BC = 0000000000000010
;      - 100 | 00000000 DE
;        000   00000000      BC = 0000000000000110
; HL remains 0, BC eventually 110 | 00000000 (1+1/2)*2 = 3
;----------------------------------------------------

_fidiv:
    push iy
    ld iy,0
    add iy,sp

    ld b,(iy+5)
    ld l,(iy+4)
    ld h,(iy+5)  

    ld c,(iy+7)
    ld e,(iy+6)
    ld d,(iy+7)
    
    ; special cases
    ld a,h
    res 7,a   ; -0 is also special
    or l     ; is hl=0?
    jr nz, _fdiv_hl_nz ; first factor is 0, return 0
    
    ld hl,0
    
    ld sp,iy
    pop iy

    ret

_fdiv_hl_nz:
    
    ld a,d
    or e
    jr nz, _fdiv_de_nz
    
    ld hl,%0111110000000000 ; second factor is zero, return infinity

    ld sp,iy
    pop iy

    ret
    
_fdiv_de_nz:    
    push bc ; store exponents
    
    ld a,h
    and %00000011 ; hl is mantissa
    ld h,a
    set 2,h ; put leading 1. HL stores numerator mantissa
    
    ld a,d
    and %00000011 ; de is mantissa
    ld d,a
    set 2,d ; put leading 1. DE stores denom mantissa
    
    ld bc,0   ; result mantissa
    ld a,10   ; number of mantissa bits (11 for 16 bit float inc lead 1)
_fdiv_loop:    

    or a
    sbc hl,de
    
    jr nc, _fdiv_L1
    add hl,de  ; de greater than total so undo sub
    
    jr _fdiv_end
_fdiv_L1:
    inc c   ; de less than or equal total so inc res
_fdiv_end:    

    add hl,hl   ; shift hl (remainder)

    sla c   ; shift result
    rl b

    dec a
    jr nz,_fdiv_loop
    
    push bc
    pop hl    ; result in HL
    
    pop bc ; get exponents back
    push bc
    pop de ; copy of exponents
    
    ld a,b
    and %01111100
    ld b,a
    sra b
    sra b   ; b is num exponent
    
    ld a,d
    and %10000000
    ld d,a  ; d is num sign
    
    ld a,c
    and %01111100
    ld c,a
    sra c
    sra c   ; c is denom exponent
    
    ld a,e
    and %10000000
    ld e,a  ; e is denom sign
    
    ld a,b
    sub c
    add a,15  ; exponent offset
    bit 2,h  ; is there a 1 at bit position 10?
    
    jr nz, _fdiv_skip
    
    dec a      ; exponent must be 1 less
    add hl,hl  ; shift hl left so 1 at bit 10
    
_fdiv_skip:

    sla a
    sla a   ; result exponent back in place

    or d    ; set to that of numerator
    xor e   ; xor with denominator sign for result
    
    ld d,a
    
    ld a,h
    and %00000011   ; get rid of leading 1
    or d            ; put on exponent and sign
    
    ld h,a

    ld sp,iy
    pop iy
        
    ret

; ----------------------------------------------------
; FSUB
; ----------------------------------------------------

_fsub:
    push iy
    ld iy,0
    add iy,sp
    
    ld l,(iy+4)
    ld h,(iy+5)

    ld e,(iy+6)
    ld d,(iy+7)

    ; special case: numbers identical    
    push hl
    or a
    sbc hl,de
    pop hl
    
    jr nz,_fsub_nz
    
    ld hl,0

    ld sp,iy
    pop iy
    ret

_fsub_nz:
        
    ld a,d
    xor %10000000
    ld d,a
    
    push de
    push hl
    call _fadd
    pop bc
    pop bc
        
    ld sp,iy
    pop iy
    ret
    
; ----------------------------------------------------
; FADD
; HL=(IY+4)*(IY+6)
;     BHL    CDE
; cdecl: arguments are passed on stack, returned as HL
; eg HL=2, DE=3, push de, push hl (right to left), call fadd, HL=5
;
; 0 01111 00|00000000 = 1.0  3C00
;+0 01110 00|00000000 = 0.5  3800

;   00000100|00000000 mantissa 1.0
;+  00000010|00000000 mantissa 0.5 (shifted right)
;   00000110|00000000
; 0 01111 10|00000000 = 1.5. (3E00) lead 1 removed, keep big exponent
; ----------------------------------------------------

_fadd:
    push iy
    ld iy,0
    add iy,sp

    ld b,(iy+5)
    ld l,(iy+4)
    ld h,(iy+5)

    ld c,(iy+7)
    ld e,(iy+6)
    ld d,(iy+7)

    ; special cases    
    ld a,d
    res 7,a  ; return if -0
    or e
    jr nz,_fadd_nz 
    
    ld sp,iy ; de= +0 or -0 so return hl
    pop iy
    ret
    
_fadd_nz:

    ld a,h
    res 7,a ; for -0
    or l
    jr nz,_hl_nz
    
    push de
    pop hl

    ld sp,iy
    pop iy
    ret  ; hl is +0 or -0 so return hl=de
    
_hl_nz:    
    ld a,h
    and %00000011 ; hl is mantissa
    ld h,a
    set 2,h ; put leading 1

    bit 7,b
    jr z,_fadd_pos1  ; positive

    ld a,h
    cpl
    ld h,a

    ld a,l
    cpl
    ld l,a

    inc hl ; 2's complement

_fadd_pos1:

    ld a,d
    and %00000011 ; de is mantissa
    ld d,a
    set 2,d ; put leading 1

    bit 7,c
    jr z,_fadd_pos2  ; positive

    ld a,d
    cpl
    ld d,a

    ld a,e
    cpl
    ld e,a

    inc de ; 2's complement

_fadd_pos2:
    res 7,b ; exponent
    srl b
    srl b

    res 7,c ; exponent
    srl c
    srl c

    ; hl exponent must be bigger or same
    ld a,b
    cp c
    jr nc, _fadd_noswap

    ex de,hl

    ld a,b
    ld b,c
    ld c,a

_fadd_noswap:
    ld a,b   ; how many places to right shift de
    sub c

    jr z, _fadd_skip

    ; make de smaller
_fadd_loop:
    sra d
    rr e
    dec a
    jr nz, _fadd_loop

_fadd_skip:
    add hl,de

    ; if result is negative, 2s complement
    ld c,0    ; result is positive (don't need DE's exponent any more)
    bit 7,h
    jr z,_fadd_skip2

    ld a,h
    cpl
    ld h,a

    ld a,l
    cpl
    ld l,a

    inc hl ; 2's complement
    
    ld c,%10000000 ; result is negative get sign bit ready

_fadd_skip2:
    ; find the lead 1 and shift as needed
    bit 3,h
    jr nz,_fadd_h3   ; eg add 1+1 get 10 need to shift right

    bit 2,h
    jr nz,_fadd_end   ; 1 is in the right place, do nothing

    bit 1,h    ; need to shift left 1 place
    jr nz,_fadd_h1
    
    bit 0,h    ; need to shift left 2 places
    jr nz,_fadd_h0

    bit 7,l    ; etc
    jr nz,_fadd_l7

    bit 6,l
    jr nz,_fadd_l6

    bit 5,l
    jr nz,_fadd_l5

    bit 4,l
    jr nz,_fadd_l4

    bit 3,l
    jr nz,_fadd_l3

    bit 2,l
    jr nz,_fadd_l2

    bit 1,l
    jr nz,_fadd_l1

    bit 0,l
    jr nz,_fadd_l0
    
    ; numbers were identical
    
    ld hl,0    ; return +0
    ret

    jr _fadd_end

_fadd_h3:
    sra h
    rr l
    inc b
    jr _fadd_end
_fadd_l0:
    sla l
    rl h
    dec b
_fadd_l1:
    sla l
    rl h
    dec b
_fadd_l2:
    sla l
    rl h
    dec b
_fadd_l3:
    sla l
    rl h
    dec b
_fadd_l4:
    sla l
    rl h
    dec b
_fadd_l5:
    sla l
    rl h
    dec b
_fadd_l6:
    sla l
    rl h
    dec b
_fadd_l7:
    sla l
    rl h
    dec b
_fadd_h0:
    sla l
    rl h
    dec b
_fadd_h1:
    sla l
    rl h
    dec b

_fadd_end:
    ld a,h
    and %00000011  ; get rid of leading 1

    sla b
    sla b

    or b ; exponent
    or c ; sign

    ld h,a

    ld sp,iy
    pop iy

    ret

; ----------------------------------------------------
; _FNEG
; ----------------------------------------------------
    
_fneg:
    push iy
    ld iy,0
    add iy,sp
    
    ld l,(iy+4)
    ld h,(iy+5)
    
    ld a,h
    xor %10000000
    ld h,a

    ld sp,iy
    pop iy
    ret
    
; ----------------------------------------------------
; FCMP(HL,DE)
; (iy+4) (iy+6)
; HL      DE
; subtract, if A < B, C=1, Z=0, if A=B, C=0, Z=1, else C=Z=0
; ----------------------------------------------------

_fcmp:
    push iy
    ld iy,0
    add iy,sp
    
    ld l,(iy+4)
    ld h,(iy+5)

    ld e,(iy+6)
    ld d,(iy+7)
    
    push de
    push hl
    
    call _fsub
    pop bc
    pop bc

    ld b,0   ; if positive A>B
    
    ld a,h
    or l
    jr nz,_fcmp_nz
    
    ld b,1   ; equal A=B
    jr _fcmp_pos
    
_fcmp_nz:

    bit 7,h
    jr z,_fcmp_pos
    
    ld b,2   ; negative A<B
    
_fcmp_pos:

    ld a,1
    sub b
    
    ld sp,iy
    pop iy
    ret
    
; ----------------------------------------------------
; _int2float
; (iy+4)
;  HL
; return HL as float
; ----------------------------------------------------

_first1:
    ld b,29   ; exponent is 29 2^(29-15) = 16384
    bit 6,h
    ret nz

    ld b,28
    bit 5,h
    ret nz

    ld b,27
    bit 4,h
    ret nz

    ld b,26
    bit 3,h
    ret nz

    ld b,25
    bit 2,h
    ret nz

    ld b,24
    bit 1,h
    ret nz
    
    ld b,23
    bit 0,h
    ret nz

    ld b,22
    bit 7,l
    ret nz

    ld b,21
    bit 6,l
    ret nz

    ld b,20
    bit 5,l
    ret nz

    ld b,19
    bit 4,l
    ret nz

    ld b,18
    bit 3,l
    ret nz

    ld b,17
    bit 2,l
    ret nz

    ld b,16
    bit 1,l
    ret nz
    
    ld b,15  ; exponent is 15 2^(15-15)=1
    ret
        
_int2float:
    push iy
    ld iy,0
    add iy,sp

    ld l,(iy+4)
    ld h,(iy+5)
    
    ; special case hl=0
    ld a,h
    or l
    jr nz,_int2float_nz
    
    ld hl,0
    ld sp,iy
    pop iy
    ret
    
_int2float_nz:
    
    ld c,0   ; sign bit is 0
    bit 7,h
    jr z, i2f_pos
    
    ld c,%10000000   ; sign bit is 1

    ld a,h  ; make int positive with 2s complement
    cpl
    ld h,a
    
    ld a,l
    cpl
    ld l,a
    inc hl
    
i2f_pos:
    
    call _first1  ; get exponent in b based on first 1 in hl
    ld a,25
    sub b         ; b=[15,29]
    
    jr z,i2f_shiftdone
    
    bit 7,a
    jr z,i2f_leftloop
    
    neg

i2f_rightloop:
    sra h
    rr l
    dec a
    jr nz,i2f_rightloop    
    jr i2f_shiftdone

i2f_leftloop:
    sla l
    rl h
    dec a
    jr nz,i2f_leftloop
    
i2f_shiftdone:

    sla b
    sla b
    
    res 2,h   ; remove leading 1
    
    ld a,h
    or b    ; exponent
    or c    ; sign
    
    ld h,a

    ld sp,iy
    pop iy
    ret

; ----------------------------------------------------
; _float2int
; (iy+4)
;  BHL
; return HL as int
; ----------------------------------------------------
        
_float2int:
    push iy
    ld iy,0
    add iy,sp

    ld b,(iy+5)
    ld l,(iy+4)
    ld h,(iy+5)
    
    ; special case hl=0.0
    ld a,h
    res 7,a
    or l
    jr nz,_float2int_nz
    
    ld hl,0
    ld sp,iy
    pop iy
    ret
    
_float2int_nz:
    
    ld c,0    ; negative?
    bit 7,b
    jr z,_f2i_pos
    ld c,1
_f2i_pos:
    ld a,b
    and %01111100
    ld b,a
    sra b
    sra b    ; b is now the exponent value (1-30)

    ld a,h
    and %00000011
    ld h,a   ; hl stores actual mantissa
    set 2,h   ; set leading 1
    
    ld a,25
    sub b    ; a is number of places we need to shift to the right
            
    cp 0
    jr z, shiftdone

    bit 7,a
    jr z,rightloop
    neg

leftloop:
    sla l
    rl h
    dec a
    jr nz,leftloop
    jr shiftdone
        
rightloop:
    sra h
    rr l
    dec a
    jr nz,rightloop    

shiftdone:    
    dec c   ; c=1, was negative
    jr nz,_f2i_end
    
    ld a,h  ; make int negative with 2s complement
    cpl
    ld h,a
    
    ld a,l
    cpl
    ld l,a
    inc hl

_f2i_end:
    ld sp,iy
    pop iy
    ret
    
; ----------------------------------------------------
; _imul_HLDE
; imul hl,de
; hl = hl*de
; ----------------------------------------------------

_imul_hlde:
    ld b,0
    bit 7,h
    jr z,_imul_hlde0

    ld a,h
    cpl
    ld h,a
    ld a,l
    cpl
    ld l,a
    inc hl

    inc b

_imul_hlde0:
    bit 7,d
    jr z,_imul_hlde1

    ld a,d
    cpl
    ld d,a
    ld a,e
    cpl
    ld e,a
    inc de

    inc b

_imul_hlde1:

    call _mul_hlde

    dec b   ; if b=1, need to negate result
    ret nz

    ld a,h
    cpl
    ld h,a

    ld a,l
    cpl
    ld h,l

    inc hl

    ret

; ----------------------------------------------------
; MUL_HLDE
; mul hl,de
; hl = hl*de
; de: 00000001 00101100 300
; hl: 00000000 01100011  99

;     00000001 00101100
;     00000010 01011000
;     00100101 10000000
;    +01001011 00000000
;
;     01110100 00000100 29700
; destroys de, ix
; ----------------------------------------------------

_mul_hlde:
    ld ix,0
    bit 0,l
    jr z,_mul_hlde1
    add ix,de

_mul_hlde1:
    sla e
    rl d
    bit 1,l
    jr z,_mul_hlde2
    add ix,de

_mul_hlde2:
    sla e
    rl d
    bit 2,l
    jr z,_mul_hlde3
    add ix,de

_mul_hlde3:
    sla e
    rl d
    bit 3,l
    jr z,_mul_hlde4
    add ix,de

_mul_hlde4:
    sla e
    rl d
    bit 4,l
    jr z,_mul_hlde5
    add ix,de

_mul_hlde5:
    sla e
    rl d
    bit 5,l
    jr z,_mul_hlde6
    add ix,de

_mul_hlde6:
    sla e
    rl d
    bit 6,l
    jr z,_mul_hlde7
    add ix,de

_mul_hlde7:
    sla e
    rl d
    bit 7,l
    jr z,_mul_hlde8
    add ix,de

; ----------------------------------------------------

_mul_hlde8:
    sla e
    rl d
    bit 0,h
    jr z,_mul_hlde9
    add ix,de

_mul_hlde9:
    sla e
    rl d
    bit 1,h
    jr z,_mul_hlde10
    add ix,de

_mul_hlde10:
    sla e
    rl d
    bit 2,h
    jr z,_mul_hlde11
    add ix,de

_mul_hlde11:
    sla e
    rl d
    bit 3,h
    jr z,_mul_hlde12
    add ix,de

_mul_hlde12:
    sla e
    rl d
    bit 4,h
    jr z,_mul_hlde13
    add ix,de

_mul_hlde13:
    sla e
    rl d
    bit 5,h
    jr z,_mul_hlde14
    add ix,de

_mul_hlde14:
    sla e
    rl d
    bit 6,h
    jr z,_mul_hlde15
    add ix,de

_mul_hlde15:
    sla e
    rl d
    bit 7,h
    jr z,_mul_hlde16
    add ix,de

_mul_hlde16:
    push ix
    pop hl

    ret

; ----------------------------------------------------
; IMUL_LE
; imul l,e
; l = l*e

; 11110100 = F4 = -12
; 00001001 = 9

; 10010100 = 94 = -108

; destroys a,b
; ----------------------------------------------------

_imul_le:
    ld b,0
    bit 7,l
    jr z,_imul_le0
    ld a,l
    neg   ;  don't put in first column or ignored!
    ld l,a
    inc b

_imul_le0:
    bit 7,e
    jr z,_imul_le1
    ld a,e
    neg
    ld e,a
    inc b

_imul_le1:
    call _mul_le
    dec b   ; if b=1, need to negate result
    ret nz
    ld a,l
    neg
    ld l,a
    ret

; ----------------------------------------------------
; MUL_LE
; mul l,e
; l = l*e
; l: 00001100 12
; e: 00010101 21

;    00001100 12
;    00110000
;    11000000
     
;    11111100 252
; destroys a
; ----------------------------------------------------

_mul_le:
    ld a,0

    bit 0,e
    jr z,_mul_le1
    add a,l

_mul_le1:
    sla l
    bit 1,e
    jr z,_mul_le2
    add a,l

_mul_le2:
    sla l
    bit 2,e
    jr z,_mul_le3
    add a,l

_mul_le3:
    sla l
    bit 3,e
    jr z,_mul_le4
    add a,l

_mul_le4:
    sla l
    bit 4,e
    jr z,_mul_le5
    add a,l

_mul_le5:
    sla l
    bit 5,e
    jr z,_mul_le6
    add a,l

_mul_le6:
    sla l
    bit 6,e
    jr z,_mul_le7
    add a,l

_mul_le7:
    sla l
    bit 7,e
    jr z,_mul_le8
    add a,l

_mul_le8:
    ld l,a

    ret

; -------------------------------------------------
; IDIV_LE
; -------------------------------------------------

_idiv_le:
    ld c,0
    bit 7,l
    jr z,_idiv_le0
    ld a,l
    neg   ;  don't put in first column or ignored!
    ld l,a
    inc c

_idiv_le0:
    bit 7,e
    jr z,_idiv_le1
    ld a,e
    neg
    ld e,a
    inc c

_idiv_le1:
    call _div_le
    dec c   ; if c=1, need to negate result
    ret nz
    ld a,l
    neg
    ld l,a
    ret
    
; -------------------------------------------------
; DIV_LE
; div l,e
; l = l/e
; remainder in a, destroys b
;a        l
;00000000 00010101 (21)
;     111 (7)
;00000000 10101000 shift left x3
;     111
;00001010 10000000 shift left x4
;     111
;00000011 10000001 a>e, so a=a-e, inc l
;     111
;00000111 00000010 shift left (all orig 1 gone from l)
;     111
;00000000 00000011 a=e, so a=a-e=0 inc l to 3 (result)

;a        l
;00000000 10000000  (128)
;      11 (3)
;00000100 00000000 shift x3
;      11
;00000001 00000001 a>e so a=a-e, inc l
;      11
;00000100 00000100 shift x2
;      11
;00000001 00000101 a>e so a=a-e, inc l
;      11
;00000100 00010100 shift x2
;      11
;00000001 00010101 a>e so a=a-e, inc l
;      11
;00000010 00101010 shift l=2A=42 (result)
; from http://z80-heaven.wikidot.com/advanced-math#toc21
; -------------------------------------------------

_div_le:
    xor a   ; a=0
    ld b,8
_div_le_loop:
    sla l
    rla
    cp e
    jr c,_div_le_skip
    sub e
    inc l
_div_le_skip:
    djnz _div_le_loop
    ret

; ----------------------------------------------------
; IDIV_HLDE
; idiv hl,de
; hl = hl/de
; remainder in ix
; ----------------------------------------------------

_idiv_hlde:
    ld c,0
    bit 7,h
    jr z,_idiv_hlde0

    ld a,h  ; hl = -hl
    cpl
    ld h,a
    ld a,l
    cpl
    ld l,a
    inc hl

    inc c

_idiv_hlde0:
    bit 7,d
    jr z,_idiv_hlde1

    ld a,d  ; de = -de
    cpl
    ld d,a
    ld a,e
    cpl
    ld e,a
    inc de

    inc c

_idiv_hlde1:

    push bc
    call _div_hlde
    pop bc

    dec c   ; if c=1, need to negate result
    ret nz

    ld a,h ; hl = -hl
    cpl
    ld h,a

    ld a,l
    cpl
    ld h,l

    inc hl

    ret

; -------------------------------------------------
; DIV_HLDE
; div hl,de
; hl=hl/de
; remainder in IX
; destroys a,bc
; from http://z80-heaven.wikidot.com/advanced-math#toc29
; -------------------------------------------------

_BC_Div_DE:
;BC/DE ==> BC, remainder in HL
;1382cc
;23 bytes

  ld hl,0    ;Accumulator
  ld a,16    ;Loop counter

_div_loop:
  ;shift the bits from BC (numerator) into HL (accumulator)
  sla c
  rl b
  adc hl,hl

  ;Check if remainder >= denominator (HL>=DE)
  or a   ; clear C, might not be needed...?
  sbc hl,de
  jr c,_div_loop_readjust
  inc c  ;  same as inc bc since low bit is always zero (could use set 7,c)
  jr _div_loop_done

_div_loop_readjust:
; remainder is not >= denominator, so we have to add DE back to HL
  add hl,de

_div_loop_done:
  dec a
  jr nz,_div_loop
  ret

_div_hlde:
    push hl
    pop bc
    call _BC_div_DE ; result in BC
    push hl
    pop ix    ; remainder in IX
    push bc
    pop hl    ; result in HL
    ret
    
; -------------------------------------------------
; equal and not equal comparison
; -------------------------------------------------

_sete:
    ld l,1
    ret z
    ld l,0
    ret

_setne:
    ld l,1
    ret nz
    ld l,0
    ret

; -------------------------------------------------
; unsigned comparison, < <= > >=
; -------------------------------------------------

; A >= B (JAE)
; L=1 if NC
_setae:
    ld l,1
    ret nc
    ld l,0
    ret

; A < B (JB)
; L=1 if C
_setb:
    ld l,1
    ret c
    ld l,0
    ret

; A <= B (JBE)
; L=1 if C or Z
_setbe:
    ld l,1
    ret c
    ret z
    ld l,0
    ret

; A > B	(JA)
; L=1 if NC and NZ
_seta:
    ld l,0
    ret c
    ret z
    ld l,1
    ret

; -------------------------------------------------
; signed comparison, < <= > >=
; -------------------------------------------------

; A > B (JG)
; L=1 if Z=0 and S=P/V

_setg:
    ld l,0
    ret z
    jp pe,_setg1
    ld l,1   ; P/V=0
    ret p    ; S=0
    ld l,0
    ret
_setg1:     ; P/V=1
    ld l,1
    ret m    ; S=1
    ld l,0
    ret

; A >= B (JGE)
; L=1 if Z=1 or S=P/V

_setge:
    ld l,1
    ret z
    jp pe,_setge1
    ld l,1   ; P/V=0
    ret p    ; S=0
    ld l,0
    ret
_setge1:     ; P/V=1
    ld l,1
    ret m    ; S=1
    ld l,0
    ret

; A < B (JL)
; L=1 if Z=0 and S != P/V

_setl:
    ld l,0
    ret z
    jp pe,_setl1
    ld l,1   ; P/V=0
    ret m    ; S=1
    ld l,0
    ret
_setl1:     ; P/V=1
    ld l,1
    ret p    ; S=0
    ld l,0
    ret

; A <= B (JLE)
; L=1 if Z=1 or S != P/V

_setle:
    ld l,1
    ret z
    jp pe,_setle1
    ld l,1   ; P/V=0
    ret m    ; S=1
    ld l,0
    ret
_setle1:     ; P/V=1
    ld l,1
    ret p    ; S=0
    ld l,0
    ret
